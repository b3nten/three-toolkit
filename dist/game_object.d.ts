import { Scene } from "./scene";
import * as Three from "three";
import { Behavior } from "./behavior";
export declare class GameObject<T extends Three.Object3D = Three.Object3D> {
    get isGameObject(): boolean;
    id?: string | symbol;
    tags: Set<string | symbol>;
    object3d: Three.Object3D<Three.Object3DEventMap>;
    scene: Scene | null;
    parent: GameObject | null;
    get position(): Three.Vector3;
    get rotation(): Three.Euler;
    get scale(): Three.Vector3;
    get quaternion(): Three.Quaternion;
    get matrix(): Three.Matrix4;
    get visible(): boolean;
    set visible(value: boolean);
    readonly children: Set<GameObject | Behavior>;
    initialized: boolean;
    spawned: boolean;
    destroyed: boolean;
    constructor();
    addChild<T extends GameObject | Behavior>(child: T): this;
    removeChild<T extends GameObject | Behavior>(child: T): T;
    addTag(tag: string | symbol): this;
    removeTag(tag: string | symbol): this;
    create(): void;
    spawn(): void;
    update(frametime: number, elapsedtime: number): void;
    despawn(): void;
    destroy(): void;
    resize(bounds: DOMRect): void;
    onCreate(): void;
    onSpawn(): void;
    onUpdate(frametime: number, elapsedtime: number): void;
    onDespawn(): void;
    onResize(bounds: DOMRect): void;
    destructor(): void;
    getChildrenByTag(tag: string | symbol): (GameObject | Behavior)[];
    getChildById(id: string | symbol): GameObject | Behavior | null;
    getBehaviorsByType<T extends string | symbol>(type: new () => T): T | null;
    getBehaviorsByTag(tag: string | symbol): Behavior[];
    getBehaviorById(id: string): Behavior | null;
    getGameObjectByType<T extends GameObject>(type: new () => T): T | null;
    getGameObjectById(id: string): GameObject | null;
    getGameObjectsByTag(tag: string): GameObject[];
    childs(): IterableIterator<GameObject | Behavior>;
}
